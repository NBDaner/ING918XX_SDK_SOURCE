#include <string.h>
#include <stdlib.h>
#include "audio_service.h"
#include "audio_codec.h"
#include "ingsoc.h"

#include "FreeRTOS.h"
#include "semphr.h"
#include "queue.h"

#include "platform_api.h"
#include "log.h"

uint8_t enc_data[] = {
0x9c,0x32,0x20,0x38,0xa8,0x88,0x7f,0xdf,0xdf,0xbf,0x7f,0x9f,0xdf,0xbf,0x7f,0xe0,0x9f,0x3f,0x7c,0x9d,0x22,0x43,0x7f,0xe8,0x9b,0x3f,0x5d,0xd9,0x65,0x74,
0x9f,0x62,0x63,0xc5,0xc8,0x33,0x5b,0x97,0x99,0xa6,0x15,0xaf,0x8c,0x21,0xa1,0x41,0x94,0x59,0x9d,0xd4,0x8e,0x9c,0xcf,0x51,0x9f,0x1d,0xe0,0x1a,0xa1,0x70,
0xae,0x37,0xad,0xb0,0x62,0xa1,0x9c,0x1c,0xe2,0xe7,
0x9c,0x32,0x20,0x59,0xdc,0xcc,0x80,0x3f,0xc1,0x40,0x86,0xc1,0xbf,0xbe,0x81,0x3e,0xbc,0x3c,0x8a,0xc4,0xb6,0xbb,0x88,0xa6,0xb7,0xaf,0xb7,0x8c,0x39,0x8c,
0xaa,0x69,0x42,0x47,0xc0,0xe5,0x42,0x32,0x9b,0x47,0xcd,0xef,0x60,0xfb,0x4a,0x9f,0x50,0xc2,0xfe,0xc6,0x89,0xe5,0x52,0x5c,0xc6,0x13,0x2e,0x39,0x4d,0xec,
0x1d,0xda,0x93,0xc7,0xf0,0x1d,0x6f,0xb1,0xfa,0x4c,
0x9c,0x32,0x20,0xbc,0xcd,0xcd,0xbd,0x70,0x78,0x71,0x8d,0x5d,0x51,0x37,0x68,0x77,0x38,0x54,0x76,0x6c,0xb8,0xcc,0xb3,0x71,0x2f,0xad,0xa7,0xa2,0x1c,0xc6,
0xae,0xa9,0x8f,0x95,0xcc,0x67,0xdd,0xc3,0x83,0x6c,0x46,0x80,0x53,0xd5,0xbf,0xa5,0x52,0x4a,0xd3,0x6c,0x62,0x83,0xe8,0xad,0x97,0x78,0xb7,0xb0,0xef,0x81,
0x3a,0xa9,0xb0,0x8c,0x20,0x53,0x82,0xaa,0x5d,0xaa,
0x9c,0x32,0x20,0x15,0xdd,0xcc,0x8b,0xa0,0x67,0xce,0x87,0x52,0x6b,0x93,0xa0,0xc8,0xe,0x4a,0x20,0x5d,0x6c,0xca,0x7e,0xc2,0x34,0xb8,0x53,0xcf,0x62,0xf,
0x66,0x67,0x23,0x6c,0x4c,0x58,0xf0,0x6b,0x5c,0x4c,0xe5,0xe8,0xb1,0xc2,0x99,0xdb,0x43,0xbd,0x58,0x92,0x99,0x2a,0xdd,0xb1,0x64,0xd2,0xd7,0x69,0x95,0x29,
0xd3,0x47,0x90,0xb2,0xc7,0x12,0xb1,0x5f,0x6d,0x36,
0x9c,0x32,0x20,0xf0,0xcc,0xcd,0x75,0x5d,0xe5,0x6e,0xde,0x98,0xad,0x5f,0xa9,0xec,0xea,0x5e,0x49,0xc9,0x75,0xba,0x68,0x36,0x66,0x78,0xa9,0x2b,0xd3,0xb1,
0x29,0x8b,0xdf,0xa0,0xce,0x55,0x58,0xc1,0x3d,0x53,0x3e,0x98,0xd3,0x28,0x5e,0x20,0x76,0x1d,0x48,0x88,0xb,0xa5,0x7,0x85,0x31,0x45,0xb1,0x7c,0x82,0x7e,0x83,
0xad,0xdb,0xcd,0x66,0x94,0xb0,0xbe,0xdd,0x39,
0x9c,0x32,0x20,0x71,0xcd,0xdd,0x81,0x9e,0xb7,0x8a,0x3b,0xbd,0x86,0xa7,0x9e,0xc6,0x89,0x82,0x41,0x85,0x74,0x62,0xcf,0x6d,0xd7,0x85,0xd5,0xaa,0x6e,0xcb,
0x9a,0xd3,0x72,0x6b,0xc3,0x7a,0x72,0xc6,0xab,0xb0,0x39,0x8e,0x1a,0x33,0x76,0x94,0x84,0x81,0x44,0x7c,0x51,0x67,0x93,0x71,0x52,0x5e,0xce,0xa8,0x4f,0x5a,
0x70,0x62,0x95,0x9f,0xac,0x86,0x6,0x72,0x6d,0xa2,
0x9c,0x32,0x20,0x44,0xdc,0xcd,0x2e,0x28,0xe7,0x68,0xc8,0xdc,0x45,0x78,0x63,0xb1,0x36,0x89,0x4c,0x47,0x35,0x31,0x4f,0x5f,0x93,0x8f,0x91,0xbd,0x39,0x7f,
0x97,0xd2,0x3b,0x7e,0x6a,0xb5,0x48,0x7c,0x95,0xf1,0x52,0x77,0x34,0x2f,0x6e,0x6c,0x5f,0xdd,0x65,0xaa,0x5f,0x4,0x5d,0x74,0x2f,0x57,0xc3,0x7c,0x74,0xb0,
0xc8,0x83,0x74,0xaf,0xc7,0x83,0xdc,0x30,0xc9,0x7d,
0x9c,0x32,0x20,0xd8,0xdd,0xdc,0x8a,0xba,0xc6,0x3c,0x54,0xc2,0x43,0x3f,0x49,0xae,0xc8,0xbb,0x92,0xe6,0x4d,0xbf,0x47,0xbf,0xa5,0x67,0xcd,0xc8,0x1f,0x4f,
0x63,0xaf,0xb7,0xd5,0xb2,0x3c,0xc7,0x3b,0xb4,0xc0,0xc1,0x3f,0xf2,0x40,0x42,0x40,0xbb,0x39,0x3e,0xb9,0x98,0xd1,0xcc,0xdc,0x3a,0x49,0x28,0xad,0xef,0x20,
0xc6,0x30,0xb0,0x4a,0x41,0x45,0x85,0x3c,0x3f,0xba,
0x9c,0x32,0x20,0x94,0xdc,0xdc,0x80,0xbf,0x3f,0xc2,0x79,0xba,0x40,0x42,0x40,0xcd,0x40,0xc0,0x59,0xb9,0x3f,0x37,0x78,0x4e,0x45,0xc8,0xb6,0x9b,0xb2,0x22,
0x5d,0xd9,0xf1,0x4a,0x96,0x43,0x4a,0xf1,0x9e,0xdd,0xa8,0x42,0x4f,0xe6,0xc7,0x75,0x96,0xc4,0xac,0xf9,0x37,0x65,0x34,0xe4,0x73,0x34,0xb7,0x1f,0xe0,0xc4,
0xc3,0xc6,0x73,0xf3,0x57,0x8f,0x72,0x48,0xda,0xda
};
pcm_sample_t dec_data[128*9] = {0};

extern void audio_input_setup(void);
extern void audio_input_start(void);
extern void audio_input_stop(void);

audio_encoder_t aud_enc_t;
void *enc = NULL;

uint8_t data_buffer[VOICE_BUF_BLOCK_NUM][VOICE_BUF_BLOCK_SIZE] = {0};
uint16_t block_index;
uint16_t byte_index;
uint16_t seq_cnt;
int8_t mic_dig_gain = 0;

#define SAMPLE_BUF_LEN  128
#define SAMPLE_BUF_CNT  2

pcm_sample_t sample_buf[SAMPLE_BUF_CNT][SAMPLE_BUF_LEN];

int sample_buf_index = 0;
int sample_index = 0;

extern void audio_trigger_send(void);

void enc_output_cb(uint8_t output, void *param)
{
    data_buffer[block_index][byte_index] = output;
    byte_index++;
#if defined(DEBUG_SBC)
    printf("[%x]",output);
#endif
    if (byte_index >= VOICE_BUF_BLOCK_SIZE)
    {
#if defined(DEBUG_SBC)
        printf("\n\n");
#endif
        block_index++;
        audio_trigger_send();
        if (block_index >= VOICE_BUF_BLOCK_NUM)
            block_index = 0;
        byte_index = 0;
    }
}

#define QUEUE_LENGTH    30
#define ITEM_SIZE       sizeof(int16_t)
static StaticQueue_t xStaticSampleQueue;
static uint8_t ucQueueStorageArea[ITEM_SIZE * QUEUE_LENGTH];
QueueHandle_t xSampleQueue;

#if (OVER_SAMPLING == 2)
#define FIR_LEN         7
#define FILTER_GAIN     1
#elif (OVER_SAMPLING == 1)
#define FIR_LEN         1
#define FILTER_GAIN     1
#endif

typedef struct
{
    int8_t h[FIR_LEN];
    pcm_sample_t x[FIR_LEN - 1];
} fir_t;

#define TO_INT8(v)       ((int8_t)(v * 127 * FILTER_GAIN))

#if (OVER_SAMPLING == 2)
fir_t fir = { .h = {TO_INT8(-0.0133217),
                    0,
                    TO_INT8(0.26318),
                    TO_INT8(0.5),
                    TO_INT8(0.26318),
                    0,
                    TO_INT8(-0.0133217)
                    } };
#elif (OVER_SAMPLING == 1)
fir_t fir = { .h = {TO_INT8(1.0)} };
#endif

void fir_push(fir_t *fir, pcm_sample_t x)
{
    int i;
    for (i = FIR_LEN - 1; i >= 2; i--)
    {
        fir->x[i - 1] = fir->x[i - 2];
    }
#if (FIR_LEN > 1)
    fir->x[0] = x;
#endif
}

pcm_sample_t fir_push_run(fir_t *fir, pcm_sample_t x)
{
    int i;
    int32_t r = fir->h[0] * x;

    for (i = FIR_LEN - 1; i >= 1; i--)
    {
        r += fir->h[i] * fir->x[i - 1];
        fir->x[i - 1] = fir->x[i - 2];
    }
#if (FIR_LEN > 1)
    fir->x[0] = x;
#endif
    return r >> 7;
}

void audio_start(void)
{
    LOG_PRINTF(LOG_LEVEL_DEBUG,"Start audio input.");
    sample_buf_index = 0;
    sample_index = 0;
    block_index = 0;
    byte_index = 0;
    audio_input_start();
}

void audio_stop(void)
{
    LOG_PRINTF(LOG_LEVEL_DEBUG,"Stop audio input.");
    xQueueReset(xSampleQueue);
    audio_input_stop();
}

static int enc_times = 10;
static void audio_task(void *pdata)
{
    int input_size, output_size;
    uint8_t *outp;
#if (AUDIO_CODEC_ALG == AUDIO_CODEC_ALG_SBC)
    input_size = sbc_get_codesize(&sbc); //codesize
    output_size = sbc_get_frame_length(&sbc);  //framelen
#elif  (AUDIO_CODEC_ALG == AUDIO_CODEC_ALG_ADPCM)
    input_size = aud_enc_t.sample_buf.size;
    output_size = aud_enc_t.sample_buf.size;
#endif
    outp = malloc(output_size * sizeof(uint8_t));

#if (OVER_SAMPLING_MASK != 0)
    int oversample_cnt = 0;
    static pcm_sample_t *buffer = NULL;
		buffer = malloc(input_size * sizeof(pcm_sample_t));
    static int buffer_index = 0;
#endif
    pcm_sample_t *buf;
    for (;;)
    {
        int16_t index;
        int i;

        if (xQueueReceive(xSampleQueue, &index, portMAX_DELAY ) != pdPASS)
            continue;

        buf = sample_buf[index];

#if (OVER_SAMPLING_MASK != 0)
        for (i = 0; i < aud_enc_t.sample_buf.size; i++)
        {
            pcm_sample_t sample = buf[i];
            oversample_cnt = (oversample_cnt + 1) & OVER_SAMPLING_MASK;
            if (oversample_cnt != 0)
            {
                fir_push(&fir, sample);
                continue;
            }
            else
            {
                sample = fir_push_run(&fir, sample);
                buffer[buffer_index++] = sample;
            }
            
            if(buffer_index >= input_size)
            {
                aud_enc_t.encoder(enc, buffer, input_size, outp, output_size);
                buffer_index = 0;
                printf("ok");
            }
        }
#else
    if(enc_times-- > 1)
    {
        aud_enc_t.encoder(enc, buf, input_size, outp, output_size);
    }
    else if(enc_times-- == 1)
    {
        audio_stop();
    }
    else
    {}
    

#endif
    }
}

uint16_t audio_get_curr_block(void)
{
    return block_index;
}

uint8_t *audio_get_block_buff(uint16_t index)
{
    return data_buffer[index];
}

void audio_rx_sample(pcm_sample_t sample)
{

    BaseType_t xHigherPriorityTaskWoke = pdFALSE;

    // digital gain
    if (mic_dig_gain > 0)
        sample <<= mic_dig_gain;
    else if (mic_dig_gain < 0)
        sample >>= -mic_dig_gain;

    sample_buf[sample_buf_index][sample_index] = sample;

    sample_index++;
    if (sample_index >= aud_enc_t.sample_buf.size)
    {
        xQueueSendFromISR(xSampleQueue, &sample_buf_index, &xHigherPriorityTaskWoke);
        sample_buf_index++;
        if (sample_buf_index >= aud_enc_t.sample_buf.num)
            sample_buf_index = 0;
        sample_index = 0;
    }
}

static void enc_state_init(audio_encoder_t *enc_t);

void audio_init(void)
{
    LOG_PRINTF(LOG_LEVEL_INFO,"Initializing audio encoder...");
    //sbc struct init.
    enc_state_init(&aud_enc_t);

    xSampleQueue = xQueueCreateStatic(QUEUE_LENGTH,
                                 ITEM_SIZE,
                                 ucQueueStorageArea,
                                 &xStaticSampleQueue);

    xTaskCreate(audio_task,
               "b",
               1024,
               NULL,
               (configMAX_PRIORITIES - 14),
               NULL);

    audio_input_setup();
    LOG_PRINTF(LOG_LEVEL_INFO,"Initialization completed.");
    // audio_start();

    sbc_dec_init(enc, NULL, 0L);
    uint8_t *ip = NULL;
    pcm_sample_t *op = NULL;
    for(int i=0;i<9;i++)
    {
        ip = enc_data + i*70;
        op = dec_data + i*128;
        printf("%x\n",ip[0]);
        sbc_decode(enc,ip,70,op,128);
    }

}

static void enc_state_init(audio_encoder_t *enc_t)
{
#if (AUDIO_CODEC_ALG == AUDIO_CODEC_ALG_ADPCM)
    LOG_PRINTF_TAB(LOG_LEVEL_INFO,"Encoder-->[ADPCM]");
    LOG_PRINTF_TAB(LOG_LEVEL_INFO,"Configure encode's parameter...");
    enc = &adpcm;
    adpcm_enc_init(enc, enc_output_cb, 0);
    enc_t->type = ADPCM_ENCODER;
    enc_t->sample_buf.num = 2;
    enc_t->sample_buf.size = 20;
    enc_t->encoder = (fun_encoder)adpcm_encode;
    LOG_PRINTF_TAB(LOG_LEVEL_INFO,"Parameter configured successfully.");

#elif (AUDIO_CODEC_ALG == AUDIO_CODEC_ALG_SBC)
    enc_t->type = SBC_ENCODER;
    LOG_PRINTF_TAB(LOG_LEVEL_INFO,"Encoder-->[SBC]");
    enc = &sbc;
    // sbc_enc_init(enc, enc_output_cb, 0L);
    // LOG_PRINTF_TAB(LOG_LEVEL_INFO,"Configure encode's parameter...");
    // enc_t->sample_buf.num = 2;
    // enc_t->sample_buf.size = sbc_get_codesize(&sbc);
    // LOG_PRINTF_TAB(LOG_LEVEL_INFO,"Parameter configured successfully.");
    // enc_t->encoder = (fun_encoder)sbc_encode;
#endif
}
